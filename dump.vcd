$date
	Wed May 20 15:55:54 2015
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module CPUTest $end
$scope module cpu $end
$scope module data_path $end
$scope module register_file $end
$var reg 8 ! \registers[0] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module CPUTest $end
$scope module cpu $end
$scope module data_path $end
$scope module register_file $end
$var reg 8 " \registers[1] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module CPUTest $end
$scope module cpu $end
$scope module data_path $end
$scope module register_file $end
$var reg 8 # \registers[2] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module CPUTest $end
$scope module cpu $end
$scope module data_path $end
$scope module register_file $end
$var reg 8 $ \registers[3] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module CPUTest $end
$scope module cpu $end
$scope module data_path $end
$scope module register_file $end
$var reg 8 % \registers[4] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module CPUTest $end
$scope module cpu $end
$scope module data_path $end
$scope module register_file $end
$var reg 8 & \registers[5] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module CPUTest $end
$scope module cpu $end
$scope module data_path $end
$scope module register_file $end
$var reg 8 ' \registers[6] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module CPUTest $end
$scope module cpu $end
$scope module data_path $end
$scope module register_file $end
$var reg 8 ( \registers[7] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module CPUTest $end
$scope module cpu $end
$scope module data_path $end
$scope module data_memory $end
$var reg 8 ) \data[100] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module CPUTest $end
$scope module cpu $end
$scope module data_path $end
$scope module data_memory $end
$var reg 8 * \data[101] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module CPUTest $end
$scope module cpu $end
$scope module data_path $end
$scope module data_memory $end
$var reg 8 + \data[102] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module CPUTest $end
$scope module cpu $end
$scope module data_path $end
$scope module data_memory $end
$var reg 8 , \data[103] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module CPUTest $end
$scope module cpu $end
$scope module data_path $end
$scope module data_memory $end
$var reg 8 - \data[104] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module CPUTest $end
$scope module cpu $end
$scope module data_path $end
$scope module data_memory $end
$var reg 8 . \data[105] [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module CPUTest $end
$scope module cpu $end
$scope module data_path $end
$scope module stack $end
$var reg 12 / \data[0] [11:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module CPUTest $end
$scope module cpu $end
$scope module data_path $end
$scope module stack $end
$var reg 12 0 \data[1] [11:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module CPUTest $end
$scope module cpu $end
$scope module data_path $end
$scope module stack $end
$var reg 12 1 \data[2] [11:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module CPUTest $end
$scope module cpu $end
$scope module data_path $end
$scope module stack $end
$var reg 12 2 \data[3] [11:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module CPUTest $end
$scope module cpu $end
$scope module data_path $end
$scope module stack $end
$var reg 12 3 \data[4] [11:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module CPUTest $end
$scope module cpu $end
$scope module data_path $end
$scope module stack $end
$var reg 12 4 \data[5] [11:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module CPUTest $end
$scope module cpu $end
$scope module data_path $end
$scope module stack $end
$var reg 12 5 \data[6] [11:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module CPUTest $end
$scope module cpu $end
$scope module data_path $end
$scope module stack $end
$var reg 12 6 \data[7] [11:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module CPUTest $end
$var wire 1 7 carry $end
$var wire 1 8 stack_overflow $end
$var wire 1 9 zero $end
$var reg 1 : clk $end
$var reg 1 ; rst $end
$scope module cpu $end
$var wire 3 < acode [2:0] $end
$var wire 1 = alu_src $end
$var wire 1 7 carry $end
$var wire 1 > clk $end
$var wire 19 ? instruction [18:0] $end
$var wire 1 @ is_halt $end
$var wire 1 A is_shift $end
$var wire 1 B mem_or_alu $end
$var wire 1 C mem_read_write $end
$var wire 2 D pc_src [1:0] $end
$var wire 1 E reg2_read_source $end
$var wire 1 F reg_read_write $end
$var wire 1 G rst $end
$var wire 2 H scode [1:0] $end
$var wire 1 8 stack_overflow $end
$var wire 1 I stack_pop $end
$var wire 1 J stack_push $end
$var wire 1 K update_z_c $end
$var wire 1 9 zero $end
$scope module data_path $end
$var wire 3 L acode [2:0] $end
$var wire 8 M alu_A [7:0] $end
$var wire 8 N alu_B [7:0] $end
$var wire 1 O alu_carry_out $end
$var wire 8 P alu_result [7:0] $end
$var wire 1 = alu_src $end
$var wire 12 Q branched_pc [11:0] $end
$var wire 1 > clk $end
$var wire 8 R data_memory_out [7:0] $end
$var wire 2 S forward_A [1:0] $end
$var wire 2 T forward_B [1:0] $end
$var wire 12 U incremented_pc [11:0] $end
$var wire 19 V instruction [18:0] $end
$var wire 1 @ is_halt $end
$var wire 1 A is_shift $end
$var wire 1 W is_stall $end
$var wire 1 B mem_or_alu $end
$var wire 1 C mem_read_write $end
$var wire 2 X pc_src [1:0] $end
$var wire 1 E reg2_read_source $end
$var wire 8 Y reg_out_1 [7:0] $end
$var wire 8 Z reg_out_2 [7:0] $end
$var wire 1 F reg_write_signal $end
$var wire 1 G rst $end
$var wire 2 [ scode [1:0] $end
$var wire 12 \ stack_out [11:0] $end
$var wire 1 8 stack_overflow $end
$var wire 1 I stack_pop $end
$var wire 1 J stack_push $end
$var wire 1 K update_z_c $end
$var wire 1 9 zero $end
$var reg 8 ] EX_alu_result [7:0] $end
$var reg 12 ^ EX_branched_pc [11:0] $end
$var reg 8 _ EX_data_2 [7:0] $end
$var reg 19 ` EX_inst [18:0] $end
$var reg 1 a EX_mem_or_alu $end
$var reg 1 b EX_mem_read_write $end
$var reg 2 c EX_pc_src [1:0] $end
$var reg 1 d EX_reg_write_signal $end
$var reg 3 e ID_acode [2:0] $end
$var reg 1 f ID_alu_src $end
$var reg 8 g ID_data_1 [7:0] $end
$var reg 8 h ID_data_2 [7:0] $end
$var reg 19 i ID_inst [18:0] $end
$var reg 1 j ID_is_shift $end
$var reg 1 k ID_mem_or_alu $end
$var reg 1 l ID_mem_read_write $end
$var reg 12 m ID_pc [11:0] $end
$var reg 2 n ID_pc_src [1:0] $end
$var reg 1 o ID_reg_write_signal $end
$var reg 2 p ID_scode [1:0] $end
$var reg 1 q ID_update_z_c $end
$var reg 19 r IF_inst [18:0] $end
$var reg 12 s IF_pc [11:0] $end
$var reg 8 t MEM_alu_result [7:0] $end
$var reg 19 u MEM_inst [18:0] $end
$var reg 1 v MEM_mem_or_alu $end
$var reg 8 w MEM_read_data [7:0] $end
$var reg 1 x MEM_reg_write_signal $end
$var reg 1 y carry $end
$var reg 12 z pc [11:0] $end
$scope module instruction_memory $end
$var wire 12 { address [11:0] $end
$var wire 1 G rst $end
$var reg 19 | instruction [18:0] $end
$upscope $end
$scope module register_file $end
$var wire 1 > clk $end
$var wire 8 } in_data [7:0] $end
$var wire 3 ~ reg_read_1 [2:0] $end
$var wire 3 !" reg_read_2 [2:0] $end
$var wire 3 "" reg_write [2:0] $end
$var wire 1 #" reg_write_signal $end
$var wire 1 G rst $end
$var integer 32 $" i [31:0] $end
$var reg 8 %" out_data_1 [7:0] $end
$var reg 8 &" out_data_2 [7:0] $end
$scope begin loop $end
$upscope $end
$scope begin loop2 $end
$upscope $end
$upscope $end
$scope module forward_selector $end
$var wire 8 '" EX_alu_result [7:0] $end
$var wire 8 (" ID_data_1 [7:0] $end
$var wire 8 )" ID_data_2 [7:0] $end
$var wire 2 *" forward_A [1:0] $end
$var wire 2 +" forward_B [1:0] $end
$var wire 8 ," mem_or_alu_data [7:0] $end
$var reg 8 -" alu_A [7:0] $end
$var reg 8 ." alu_B [7:0] $end
$upscope $end
$scope module alu $end
$var wire 8 /" A [7:0] $end
$var wire 8 0" B [7:0] $end
$var wire 3 1" acode [2:0] $end
$var wire 1 7 carry_in $end
$var wire 1 2" is_shift $end
$var wire 1 G rst $end
$var wire 2 3" scode [1:0] $end
$var wire 1 4" update_z_c $end
$var reg 8 5" R [7:0] $end
$var reg 1 6" carry_out $end
$var reg 8 7" neg_B [7:0] $end
$var reg 9 8" temp [8:0] $end
$var reg 16 9" temp2 [15:0] $end
$var reg 1 :" zero $end
$scope function get_carry_out $end
$var reg 8 ;" A [7:0] $end
$var reg 8 <" B [7:0] $end
$var reg 8 =" C [7:0] $end
$var reg 1 >" get_carry_out $end
$upscope $end
$upscope $end
$scope module data_memory $end
$var wire 8 ?" address [7:0] $end
$var wire 1 > clk $end
$var wire 1 @" read_write $end
$var wire 1 G rst $end
$var wire 8 A" write_data [7:0] $end
$var integer 32 B" i [31:0] $end
$var reg 8 C" read_data [7:0] $end
$scope begin loop $end
$upscope $end
$upscope $end
$scope module stack $end
$var wire 1 > clk $end
$var wire 1 I pop_sig $end
$var wire 12 D" push_data [11:0] $end
$var wire 1 J push_sig $end
$var wire 1 G rst $end
$var integer 32 E" i [31:0] $end
$var reg 1 F" overflow $end
$var reg 12 G" pop_data [11:0] $end
$var reg 4 H" stack_pointer [3:0] $end
$scope begin loop2 $end
$upscope $end
$upscope $end
$scope module forwarding_unit $end
$var wire 19 I" EX_inst [18:0] $end
$var wire 1 J" EX_reg_write_signal $end
$var wire 19 K" ID_inst [18:0] $end
$var wire 19 L" MEM_inst [18:0] $end
$var wire 1 #" MEM_reg_write_signal $end
$var wire 1 E reg2_read_source $end
$var reg 2 M" forward_A [1:0] $end
$var reg 2 N" forward_B [1:0] $end
$upscope $end
$scope module hazard_detector $end
$var wire 19 O" ID_inst [18:0] $end
$var wire 1 P" ID_mem_read_write $end
$var wire 19 Q" IF_inst [18:0] $end
$var wire 1 E reg2_read_source $end
$var reg 1 R" is_stall $end
$upscope $end
$upscope $end
$scope module controller $end
$var wire 1 7 carry $end
$var wire 1 > clk $end
$var wire 19 S" instruction [18:0] $end
$var wire 1 @ is_halt $end
$var wire 1 G rst $end
$var wire 1 9 zero $end
$var reg 3 T" acode [2:0] $end
$var reg 1 U" alu_src $end
$var reg 1 V" is_shift $end
$var reg 1 W" mem_or_alu $end
$var reg 1 X" mem_read_write $end
$var reg 2 Y" pc_src [1:0] $end
$var reg 1 Z" reg2_read_source $end
$var reg 1 [" reg_write_signal $end
$var reg 2 \" scode [1:0] $end
$var reg 1 ]" stack_pop $end
$var reg 1 ^" stack_push $end
$var reg 1 _" update_z_c $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
1_"
0^"
0]"
b0 \"
1["
0Z"
b0 Y"
0X"
1W"
0V"
0U"
b0 T"
b0 S"
0R"
b0 Q"
0P"
b0 O"
b0 N"
b0 M"
b0 L"
b0 K"
0J"
b0 I"
b0 H"
bx G"
0F"
b1000 E"
b1 D"
bx C"
b110 B"
b0 A"
0@"
b0 ?"
x>"
bx ="
bx <"
bx ;"
0:"
bx 9"
b0 8"
b0 7"
06"
b0 5"
04"
b0 3"
02"
b0 1"
b0 0"
b0 /"
b0 ."
b0 -"
b0 ,"
b0 +"
b0 *"
b0 )"
b0 ("
b0 '"
b0 &"
b0 %"
b1000 $"
0#"
b0 ""
b0 !"
b0 ~
b0 }
b100000100000000001 |
b1 {
b1 z
xy
0x
b0 w
0v
b0 u
b0 t
b0 s
b0 r
0q
b0 p
0o
b0 n
b0 m
0l
0k
0j
b0 i
b0 h
b0 g
0f
b0 e
0d
b0 c
0b
0a
b0 `
b0 _
b0 ^
b0 ]
bx \
b0 [
b0 Z
b0 Y
b0 X
0W
b100000100000000001 V
b10 U
b0 T
b0 S
bx R
b0 Q
b0 P
0O
b0 N
b0 M
b0 L
1K
0J
0I
b0 H
xG
1F
0E
b0 D
0C
1B
0A
0@
b0 ?
1>
0=
b0 <
x;
1:
09
08
x7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
bx ,
bx +
bx *
bx )
bx (
bx '
bx &
bx %
bx $
bx #
bx "
b0 !
$end
#20
1U"
1=
1_"
1K
1["
1F
1W"
1B
bx }
bx ,"
b100000100000000001 r
b100000100000000001 ?
b100000100000000001 Q"
b100000100000000001 S"
b10 s
b11 D"
1o
1k
1q
14"
bx w
b1000 $"
0:
0>
#40
b11 U
b100001000000000010 |
b100001000000000010 V
1_"
1K
1["
1F
1U"
1=
1W"
1B
b10 z
b10 {
0y
07
b1000 $"
1:
1>
#60
1_"
1K
1["
1F
1U"
1=
1W"
1B
b1 5"
b1 P
0>"
b1 ="
b1 <"
b0 ;"
b1 8"
b11111111 7"
b1 0"
1a
1d
1J"
b100000100000000001 i
b100000100000000001 K"
b100000100000000001 O"
b10 m
b11 Q
1f
b100001000000000010 r
b100001000000000010 ?
b100001000000000010 Q"
b100001000000000010 S"
b11 s
b100 D"
b1000 $"
0:
0>
#80
b100 U
b1100101000000 |
b1100101000000 V
1_"
1K
1["
1F
1U"
1=
1W"
1B
b11 z
b11 {
b1000 $"
1:
1>
#100
1_"
1K
1["
1F
0U"
0=
1W"
1B
b10 5"
b10 P
b10 ="
b10 <"
b10 8"
b11111110 7"
b0 !
bx &"
bx Z
bx %"
bx Y
b10 !"
b10 0"
b1 ~
1R"
1W
b0 }
b0 ,"
b1100101000000 r
b1100101000000 ?
b1100101000000 Q"
b1100101000000 S"
b100 s
b101 D"
b100001000000000010 i
b100001000000000010 K"
b100001000000000010 O"
b11 m
b101 Q
b100000100000000001 `
b100000100000000001 I"
b1 ]
b1 '"
b1 ?"
b11 ^
1v
1x
1#"
b1000 $"
0:
0>
#120
b101 U
b1111111111111111111 |
b1111111111111111111 V
1_"
1K
1["
1F
1W"
1B
b100 z
b100 {
b0 !
b1000 $"
1:
1>
#140
0_"
0K
0["
0F
0W"
0B
b10 ."
b10 N
0:"
09
b11 5"
b11 P
06"
0O
0>"
b11 ="
b10 <"
b1 ;"
b11 8"
b11111110 7"
b0 !
b111 !"
b1 ""
b1 }
b1 ,"
b10 M"
b10 S
b10 *"
b1 N"
b1 T
b1 +"
bx )"
b1 -"
b1 M
b1 /"
b10 0"
b111 ~
0R"
0W
b100000100000000001 u
b100000100000000001 L"
b1 t
b100001000000000010 `
b100001000000000010 I"
b10 ]
b10 '"
b10 ?"
b101 ^
b1100101000000 i
b1100101000000 K"
b1100101000000 O"
bx h
bx g
bx ("
b100 m
b1000100 Q
0f
b1111111111111111111 r
b1111111111111111111 ?
b1111111111111111111 Q"
b1111111111111111111 S"
b101 s
b110 D"
b1000 $"
0:
0>
#160
b110 U
bx |
bx V
b1 "
b101 z
b101 {
b1000 $"
1:
1>
#180
bx 7"
b0 !
bx !"
bx 0"
bx 5"
bx P
bx 8"
bx ~
bx ."
bx N
bx -"
bx M
bx /"
b10 ""
b0 N"
b0 T
b0 +"
b0 M"
b0 S
b0 *"
b10 }
b10 ,"
bx r
bx ?
bx Q"
bx S"
b110 s
b111 D"
b1111111111111111111 i
b1111111111111111111 K"
b1111111111111111111 O"
b101 m
b100 Q
0o
0k
0q
04"
bx _
bx A"
b1100101000000 `
b1100101000000 I"
b11 ]
b11 '"
b11 ?"
b1000100 ^
b100001000000000010 u
b100001000000000010 L"
b10 t
b1000 $"
0:
0>
#200
b111 U
b110 z
b110 {
b10 #
b1000 $"
1:
1>
#220
b11 ""
b11 }
b11 ,"
b1100101000000 u
b1100101000000 L"
b11 t
0a
b1111111111111111111 `
b1111111111111111111 I"
0d
0J"
bx ]
bx '"
bx ?"
b100 ^
bx i
bx K"
bx O"
b110 m
bx Q
b111 s
b1000 D"
b1000 $"
0:
0>
#240
b1000 U
b11 $
b111 z
b111 {
b1000 $"
1:
1>
#260
b111 ""
bx }
bx ,"
b1000 s
b1001 D"
b111 m
bx `
bx I"
bx ^
0v
b1111111111111111111 u
1@
b1111111111111111111 L"
0x
0#"
bx t
b1000 $"
0:
0>
#280
b1001 U
b1000 z
b1000 {
b1000 $"
1:
1>
#285
